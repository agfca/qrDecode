
var http = require('http');
var fs = require('fs');
var path = require('path');

/**
 * 添加上传参数
 * @param fields  {fieldName:'field名称', fieldValue:'field内容'} 
 */
function writeField(field , boundaryKey){
    return (boundaryKey + '\r\n'
            +'Content-Disposition: form-data; name="'+field.fname +'"\r\n\r\n'
            +field.fvalue+'\r\n');
}

/**
 * 添加上传文件
 * @param  filePath
 */
function writeFileContent(filePath , boundaryKey){
        return ( 
          boundaryKey + '\r\n'
          + 'Content-Type: Content-Type: text/plain\r\n' 
          + 'Content-Disposition: form-data; name="file"; filename="'+path.basename(filePath)+'"\r\n'
          + 'Content-Transfer-Encoding: binary\r\n\r\n' 
        );
        
}

/**
 * 上传文件
 * @param {Object}filePath
 * @param {Array}fields {fname:'' , fvalue:''}
 * @param options {error , success}
 */
var upload = function(filePath , fields , options){
    
    options = options || {};
    var error =   options.error || function(){};
    var success = options.success || function(){};
    
    var boundaryKey = Math.random().toString(16); // random string
    var startdata = '--'+boundaryKey;
    var enddata = '\r\n--' + boundaryKey + '--';
    
    var content = "";
    if(fields && fields.length >0){
        for(var i=0 ; i<fields.length ; i++){
            var field = fields[i];
            content += writeField(field , startdata);
        }
    }
    
    
    var contentBinary = new Buffer(content, 'utf-8');//当编码为ascii时，中文会乱码。
    
    if(filePath){
        content += writeFileContent(filePath , startdata);
        contentBinary = new Buffer(content, 'utf-8');
        var contentLength = contentBinary.length;
        var stat = fs.statSync(filePath);
        contentLength += stat.size;
    };
    
    
    var options = {
        hostname: 'secure.fsync2.ifeng.com',
        port: 80,
        path: '/sync/sync.do',
        method: 'POST',
        headers: {
          'Content-Type': 'multipart/form-data; boundary="'+boundaryKey+'"',
          'Content-Length' : contentLength + Buffer.byteLength(enddata)
        }
    };
    
    
    var request = http.request(options , function(res){

        res.on('data' , function(content){
            if(content){
               var retCode = /<ret>\s*(\S*)\s*<\/ret>/i.exec(content);

               if(retCode[1] != '0'){
                    var arr  = /<msg>(.*)<\/msg>/i.exec(content);
                    error('cndError' , filePath , arr[1] ,retCode[1]);
               }else{
                    success(filePath);
               }
            }else{
               error('cndError' , filePath , 'no response data');
            }
        });
    });
    
    request.on('error', function(e) {
       error('reqError' , filePath , e);
    });
    
    request.on('timeout' , function(){
       error('resTimeout' , filePath , 'response timeout');
    });
    
    request.write(contentBinary);
    if(filePath){
        fs.readFile(filePath , function(error , content){
           if(error){
              request.abort();
              error('readFileError' , filePath , e);
           }
           request.write(content);
           request.end(enddata);  
        });
        
    }else{
        request.end(enddata);
    }
}

module.exports = upload;
